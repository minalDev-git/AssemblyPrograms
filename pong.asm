DOSSEG
.MODEL SMALL
.STACK 100H
.DATA

;BOUNDARIES OF THE SCREEN FOR CHECKING COLLISIONS
WINDOW_WIDTH DW 140H 			;THE WIDTH OF THE SCREEN (320 PIXES)
WINDOW_HEIGHT DW 0C8H 			;THE HEIGHT OF THE SCREEN (200 PIXES)
WINDOW_BOUNDS DW 6 				;VARIABLE USED TO CHECK COLLISIONS EARLY

TIME_AUX DB 0 					;VARIABLE USED WHEN CHECKING IF TIME HAVE CHANGED
GAME_ACTIVE DB 1				;is the game active> (1 -> Yes, 0 -> No (game over))
WINNER_INDEX DB 0				;THE INDEX OF THE WINNER (1 -> PLAYER ONE, 2 -> PLAYER 2)
CURRENT_SCENE DB 0				;THE INDEX OF THE CURRENT SCENE (0 -> MAIN MENU, 1 -> GAME)
EXITING_GAME DB 0 				;THE INDEX OF THE EXIT GAME STATUS (0 -> PLAY GAME, 1 -> EXIT)

TEXT_PLAYER_ONE_POINTS DB '0','$' 								;TEXT with player one points
TEXT_PLAYER_TWO_POINTS DB '0','$' 								;TEXT with player two points
TEXT_GAME_OVER_TITLE DB 'GAME OVER','$' 						;TEXT with THE GAME OVER MENU TITLE
TEXT_GAME_OVER_WINNER DB 'PLAYER 0 WON','$' 					;TEXT with WINNER 
TEXT_GAME_OVER_PLAY_AGAIN DB 'PRESS R TO START AGAIN','$' 		;TEXT WITH THE GAME OVER PLAY AGAIN MESSAGE
TEXT_GAME_OVER_MAIN_MENU DB 'PRESS E TO EXIT TO MAIN MENU','$'	;TEXT WITH THE GAME OVER MAIN MENU MESSAGE
TEXT_MAIN_MENU_TITLE DB 'MAIN MENU','$'							;TEXT WITH MAIN MENU TITLE
TEXT_MAIN_MENU_SINGLEPLAYER DB 'SINGLEPLAYER - S KEY','$'		;;TEXT WITH THE SINGLEPLAYER MESSAGE
TEXT_MAIN_MENU_MULTIPLAYER DB 'MULTIPLAYER - M KEY','$'			;TEXT WITH THE MULTIPLAYER MESSAGE
TEXT_MAIN_MENU_EXIT DB 'EXIT GAME - E KEY','$'					;TEXT with THE EXIT GAME MESSAGE

;VARIABLES TO RESET BALL'S POSITION
BALL_ORIGINAL_X DW 0A0H 		; X-POSITION OF THE BALL AT THE START OF THE GAME
BALL_ORIGINAL_Y DW 64H 			;Y-POSITION OF THE BALL AT THE START OF THE GAME

BALL_X DW 0A0H 					;CURRENT X POS (COL) OF THE BALL
BALL_Y DW 64H 					;CURRENT Y POS (ROW) OF THE BALL
BALL_SIZE DW 04H 				;SIZE OF THE BALL (4 x 4) PIXELS

BALL_VELOCITY_X DW 05H 			;X (HORIZONTAL) VELOCITY OF THE BALL
BALL_VELOCITY_Y DW 02H 			;Y (VERTICAL) VELOCITY OF THE BALL

;CREATING THE LEFT PADDLE
PADDLE_LEFT_X DW 0AH 			;CURRENT X-POS OF LEFT PADDLE
PADDLE_LEFT_Y DW 55H 			;CURRENT Y-POS OF LEFT PADDLE
PLAYER_ONE_POINTS DB 0			;CURRENT POINTS OF THE LEFT PLAYER (PLAYER ONE)

;CREATING THE RIGHT PADDLE
PADDLE_RIGHT_X DW 130H 			;CURRENT X-POS OF RIGHT PADDLE
PADDLE_RIGHT_Y DW 55H  			;CURRENT Y-POS OF RIGHT PADDLE
PLAYER_TWO_POINTS DB 0			;CURRENT POINTS OF THE RIGHT PLAYER (PLAYER TWO)

PADDLE_WIDTH DW 05H 			;DEFAULT PADDLE WIDTH
PADDLE_HEIGHT DW 1FH 			;DEFAULT PADDLE HEIGHT
PADDLE_VELOCITY DW 05H 			;DEFAULT Y (VERTICAL) VELOCITY OF THE PADDLE
.CODE
MAIN PROC
	MOV AX,@DATA
	MOV DS,AX
	
	CALL CLEAR_SCREEN 			;SET INITIAL VIDEO MODE CONFIGURATION
	
	;we need to call "DRAW_BALL" after some time to move the ball in all 4 directions
	;to acheive this we need to use time.when we update the ball position later on,and erase the screen and draw ball with updated position
	;to give the illusion of movement
	;we will need to get system time and check if 100th of second has passed
	
	CHECK_TIME: ;TIME CHECKING LOOP
		
		CMP EXITING_GAME,01H
		JE START_EXIT_PROCESS
		
		CMP CURRENT_SCENE,00H
		JE SHOW_MAIN_MENU
		
		;before drawing and checking everything we'll check if the game is not active
		CMP GAME_ACTIVE,00H
		JE SHOW_GAME_OVER_MENU	;IF yes -> show game_over_menu, If No -> continue with the processing
		
		MOV AH,2CH 				;GET system time FUNCTION
		INT 21H 				;Returns CH = hours (0-23),CL = minutes (0-59), DH = seconds (0-59) , and DL = 1/100 SECONDS
		
		CMP DL,TIME_AUX 		;IS THE CURRENT TIME = PREV ONE(TIME_AUX) ?
		JE CHECK_TIME 			;IF IT IS EQUAL,CHECK AGAIN
		
		;IF IT IS DIFFERENT, DRAW,MOVE ETC. ;IF IT reaches this point, the time has passed
		MOV TIME_AUX,DL 		;UPDATE TIME_AUX VAR TO CURRENT 1/100ths OF second
		
		CALL CLEAR_SCREEN       ;clear the screen by restarting the video mode
		CALL MOVE_BALL			;move the ball
		CALL DRAW_BALL			;draw the ball
		
		CALL MOVE_PADDLES       ;move the two paddles (check for pressing of keys)
		CALL DRAW_PADDLES 		;DRAWS BOTH LEFT AND RIGHT PADDLES with updated positions
		
		CALL DRAW_UI			;DRAW THE GAME USER INTERFACE
		
		JMP CHECK_TIME 			;AFTER EVERYTHING, CHECK TIME AGAIN
		
		SHOW_GAME_OVER_MENU:
			CALL DRAW_GAME_OVER_MENU
			JMP CHECK_TIME 		;JUMP TO THE GAME LOOP FOR NOW
			
		SHOW_MAIN_MENU:
			CALL DRAW_MAIN_MENU
			JMP CHECK_TIME
			
		START_EXIT_PROCESS:
			CALL CONCLUDE_EXIT_GAME
	
	MOV AH,4CH
	INT 21H
MAIN ENDP

MOVE_BALL PROC			;processes the ball movement
	;WE WANT TO MOVE THE BALL WITH SPEED SO: BALL_X = BALL_X + VELOCITY_X & BALL_Y = BALL_Y + VELOCITY_Y
	
	;MOVE THE BALL HORIZONTALLY
	MOV AX,BALL_VELOCITY_X 
	ADD BALL_X,AX 
	
	;check if the ball has passed the left boundary (BALL_X < 0 + WINDOW_BOUNDS)
	;if it is coliding, restart its position
	MOV AX,WINDOW_BOUNDS
	CMP BALL_X,AX 							;BALL_X is compared with left boundaries of the screen (0 + WINDOW_BOUNDS)
	JL GIVE_POINT_TO_PLAYER_TWO				;IF BALL_X < 0 + WINDOW_BOUNDS (T: COLLISION WITH LEFT BOUNDARY) reset ball position AND give one point to player two
	
	;check if the ball has passed the right boundary (BALL_X > WINDOW_WIDTH - BALL_SIZE - WINDOW_BOUNDS)
	;if it is coliding, restart its position
	MOV AX,WINDOW_WIDTH;
	SUB AX,BALL_SIZE
	SUB AX,WINDOW_BOUNDS
	CMP BALL_X,AX 						;IF BALL_X > WINDOW_WIDTH - BALL_SIZE - WINDOW_BOUNDS (T: COLLISION WITH RIGHT BOUNDARY)
	JG  GIVE_POINT_TO_PLAYER_ONE		;if it is greater, reset position and give one point to player one
	JMP MOVE_BALL_VERTICALLY
	
	;FOLLOWING PROCEDURE "RESET_BALL_POSITION" REVERSES THE BALL'S DIRECTION
	;CONVERTS BALL_VELOCITY_X = - BALL_VELOCITY_X  (NEG = -VE)
	
	GIVE_POINT_TO_PLAYER_ONE: 			;GIVE ONE POINT TO PLAYER ONE
	
		INC PLAYER_ONE_POINTS
		;NOW INSTEAD OF REVERSING BALL'S DIRECTION WE WILL RESET IT'S position SO WE REPLACED NEG_VELOCITY_X WITH RESET_POSITION
		CALL RESET_BALL_POSITION 			;reset ball position to center of screen
		
		CALL UPDATE_TEXT_PLAYER_ONE_POINTS  ;UPDATE THE TEXT OF PLAYER ONE POINTS
		
		;check if this player has reached 5 points
		CMP PLAYER_ONE_POINTS,05H
		JGE GAME_OVER						;IF THIS PLAYER POINTS >= 5, GAME IS OVER
		RET
	
	GIVE_POINT_TO_PLAYER_TWO: 			;GIVE ONE POINT TO PLAYER TWO
	
		INC PLAYER_TWO_POINTS
		;NOW INSTEAD OF REVERSING BALL'S DIRECTION WE WILL RESET IT'S position SO WE REPLACED NEG_VELOCITY_X WITH RESET_POSITION
		CALL RESET_BALL_POSITION 			;reset ball position to center of screen
		
		CALL UPDATE_TEXT_PLAYER_TWO_POINTS	;UPDATE THE TEXT OF PLAYER TWO POINTS
		;check if this player has reached 5 points
		CMP PLAYER_TWO_POINTS,05H
		JGE GAME_OVER						;IF THIS PLAYER POINTS >= 5, GAME IS OVER
		RET
		
	GAME_OVER:								;someone has reached 5 points
	
		CMP PLAYER_ONE_POINTS,05H			;CHECK WHICH PLAYER HAS 5 POINTS
		JNL WINNER_IS_PLAYER_ONE 			;IF P1 POINTS IS NOT LESS THAN 5 (WINNER -> P1, ELSE WINNER -> P2)
		JMP WINNER_IS_PLAYER_TWO
		
		WINNER_IS_PLAYER_ONE:
			MOV WINNER_INDEX,01H			;UPDATE WINNER_INDEX WITH PLAYER 1 INDEX
			JMP CONTINUE_GAME_OVER			
			
		WINNER_IS_PLAYER_TWO:
			MOV WINNER_INDEX,02H			;UPDATE WINNER_INDEX WITH PLAYER 2 INDEX
			JMP CONTINUE_GAME_OVER
		
		CONTINUE_GAME_OVER:
			MOV PLAYER_ONE_POINTS,00H			;restart player one points
			MOV PLAYER_TWO_POINTS,00H			;restart player two points
			CALL UPDATE_TEXT_PLAYER_ONE_POINTS
			CALL UPDATE_TEXT_PLAYER_TWO_POINTS
			MOV GAME_ACTIVE,00H 				;STOPS the game
			RET
	
	;MOVE THE BALL VERTICALLY
	MOVE_BALL_VERTICALLY:
		MOV AX,BALL_VELOCITY_Y 
		ADD BALL_Y,AX 
	
	;check if the ball has passed the top boundary (BALL_Y < 0 + WINDOW_BOUNDS)
	;if it is coliding, reverse the velocity in Y
	MOV AX,WINDOW_BOUNDS
	CMP BALL_Y,AX				;IF BALL_Y < 0 + WINDOW_BOUNDS (T: COLLISION WITH TOP BOUNDARY)
	JL NEG_VELOCITY_Y 			;if it is less, reverse velocity in Y
	
	;check if the ball has passed the bottom boundary (BALL_Y > WINDOW_HEIGHT - BALL_SIZE - WINDOW_BOUNDS)
	;if it is coliding, reverse the velocity in Y
	MOV AX,WINDOW_HEIGHT
	SUB AX,BALL_SIZE
	SUB AX,WINDOW_BOUNDS
	CMP BALL_Y,AX 				;IF BALL_Y > WINDOW_HEIGHT - BALL_SIZE - WINDOW_BOUNDS (T: COLLISION WITH BOTTOM BOUNDARY)
	JG NEG_VELOCITY_Y			;if it is greater, reverse velocity in Y
	
	;check if the ball is colliding with the right paddel
	
	;Axis Aligned Bounding Boxes collision method: (maxx1 > minx2 && minx1 < maxx2 && maxy1 > miny2 && miny1 < maxy2)
	; BALL_X + BALL_SIZE > PADDLE_RIGHT_X && BALL_X < PADDLE_RIGHT_X + PADDLE_WIDTH 
	; && BALL_Y + BALL_SIZE > PADDLE_RIGHT_Y && BALL_Y < PADDLE_RIGHT_Y + PADDLE_HEIGHT
	
	; BALL_X + BALL_SIZE > PADDLE_RIGHT_X (THIS CONDITION IS CHECKED HERE)
	MOV AX,BALL_X
	ADD AX,BALL_SIZE
	CMP AX,PADDLE_RIGHT_X
	JNG CHECK_COLLISION_WITH_LEFT_PADDLE ;IF THERE IS NO COLLISION, CHECK FOR THE LEFT PADDLE collision
	
	;BALL_X < PADDLE_RIGHT_X + PADDLE_WIDTH (THIS CONDITION IS CHECKED HERE)
	MOV AX,PADDLE_RIGHT_X
	ADD AX,PADDLE_WIDTH
	CMP BALL_X,AX
	JNL CHECK_COLLISION_WITH_LEFT_PADDLE ;IF THERE IS NO COLLISION, CHECK FOR THE LEFT PADDLE collision
	
	;BALL_Y + BALL_SIZE > PADDLE_RIGHT_Y (THIS CONDITION IS CHECKED HERE)
	MOV AX,BALL_Y
	ADD AX,BALL_SIZE
	CMP AX,PADDLE_RIGHT_Y
	JNG CHECK_COLLISION_WITH_LEFT_PADDLE ;IF THERE IS NO COLLISION, CHECK FOR THE LEFT PADDLE collision
	
	;BALL_Y < PADDLE_RIGHT_Y + PADDLE_HEIGHT (THIS CONDITION IS CHECKED HERE)
	MOV AX,PADDLE_RIGHT_Y
	ADD AX,PADDLE_HEIGHT
	CMP BALL_Y,AX
	JNL CHECK_COLLISION_WITH_LEFT_PADDLE ;IF THERE IS NO COLLISION, CHECK FOR THE LEFT PADDLE collision
	
	;if reaches this point, the ball is colliding with right paddle
	
	JMP NEG_VELOCITY_X		;reverse the ball's horizontal velocity
	;exit PROCEDURE b/c the ball will not collide with the 2 paddles at the same time. no collision with left paddle
	
	;check if the ball is colliding with the left paddel
	CHECK_COLLISION_WITH_LEFT_PADDLE:
	
	;Axis Aligned Bounding Boxes collision method: (maxx1 > minx2 && minx1 < maxx2 && maxy1 > miny2 && miny1 < maxy2)
	; BALL_X + BALL_SIZE > PADDLE_LEFT_X && BALL_X < PADDLE_LEFT_X + PADDLE_WIDTH 
	; && BALL_Y + BALL_SIZE > PADDLE_LEFT_Y && BALL_Y < PADDLE_LEFT_Y + PADDLE_HEIGHT
	
	; BALL_X + BALL_SIZE > PADDLE_LEFT_X (THIS CONDITION IS CHECKED HERE)
	MOV AX,BALL_X
	ADD AX,BALL_SIZE
	CMP AX,PADDLE_LEFT_X
	JNG EXIT_COLLISION_CHECK ;IF THERE IS NO COLLISION, EXIT PROCEDURE
	
	;BALL_X < PADDLE_LEFT_X + PADDLE_WIDTH (THIS CONDITION IS CHECKED HERE)
	MOV AX,PADDLE_LEFT_X
	ADD AX,PADDLE_WIDTH
	CMP BALL_X,AX
	JNL EXIT_COLLISION_CHECK ;IF THERE IS NO COLLISION, EXIT PROCEDURE
	
	;BALL_Y + BALL_SIZE > PADDLE_LEFT_Y (THIS CONDITION IS CHECKED HERE)
	MOV AX,BALL_Y
	ADD AX,BALL_SIZE
	CMP AX,PADDLE_LEFT_Y
	JNG EXIT_COLLISION_CHECK ;IF THERE IS NO COLLISION, EXIT PROCEDURE
	
	;BALL_Y < PADDLE_LEFT_Y + PADDLE_HEIGHT (THIS CONDITION IS CHECKED HERE)
	MOV AX,PADDLE_RIGHT_Y
	ADD AX,PADDLE_HEIGHT
	CMP BALL_Y,AX
	JNL EXIT_COLLISION_CHECK ;IF THERE IS NO COLLISION, EXIT PROCEDURE
	
	;if reaches this point, the ball is colliding with LEFT paddle
	JMP NEG_VELOCITY_X
	
	NEG_VELOCITY_Y:				;reverse velocity in y of the ball BALL_VELOCITY_Y = - BALL_VELOCITY_Y
		NEG BALL_VELOCITY_Y
		RET
	NEG_VELOCITY_X:		
		NEG BALL_VELOCITY_X 		;reverse the ball's horizontal velocity
		RET							;exit PROCEDURE b/c the ball will not collide with the 2 paddles at the same time. no collision with RIGHT paddle
		
	EXIT_COLLISION_CHECK:
		RET
		
MOVE_BALL ENDP

MOVE_PADDLES PROC				;process ball monement
	;FOR LEFT PADDLE MOVEMENT
	
	;CHECK IF ANY KEY IS PRESSED (IF NOT CHECK THE OTHER PADDLE)
	MOV AH,01H ;GET KEYBOARD STATUS FUNCTION
	INT 16H
	;MEANS IF ZERO FLAG IS SET,WE JUMP TO CHECK THE OTHER PADDLE
	JZ CHECK_RIGHT_PADDLE_MOVEMENT ;(IF ZF = 0 -> KEY IS PRESSED)  JZ = JUMP IF ZERO
	
	;CHECK WHICH KEY IS BEING PRESSED (AL = ASCII CHARACTER OF THE KEY WHICH IS PRESSED)
	MOV AH,00H
	INT 16H
	
	;IF IT IS 'w' OR 'W' MOVE UP
	CMP AL,77H ;ASCII FOR 'w' IN HEX
	JE MOVE_LEFT_PADDLE_UP
	
	CMP AL,57H ;ASCII FOR 'W' IN HEX
	JE MOVE_LEFT_PADDLE_UP
	
	;IF IT IS 's' OR 'S' MOVE DOWN
	CMP AL,73H ;ASCII FOR 's' IN HEX
	JE MOVE_LEFT_PADDLE_DOWN
	
	CMP AL,53H ;ASCII FOR 'S' IN HEX
	JE MOVE_LEFT_PADDLE_DOWN
	
	;IF EITHER IS NOT THE CASE,THEN THE KEY PRESS IS MAYBE FOR THE RIGHT PADDLE
	JMP CHECK_RIGHT_PADDLE_MOVEMENT
	
	MOVE_LEFT_PADDLE_UP:
		MOV AX,PADDLE_VELOCITY
		SUB PADDLE_LEFT_Y,AX
		MOV AX,WINDOW_BOUNDS ;CHECK IF PADDLE_LEFT_Y > WINDOWS_BOUNDS (F: JUMP TO FIX_PADDLE_LEFT_TOP_POSITION)
		CMP PADDLE_LEFT_Y,AX
		JL FIX_PADDLE_LEFT_TOP_POSITION
		JMP CHECK_RIGHT_PADDLE_MOVEMENT
		
		FIX_PADDLE_LEFT_TOP_POSITION:
			MOV AX,WINDOW_BOUNDS
			MOV PADDLE_LEFT_Y,AX
			JMP CHECK_RIGHT_PADDLE_MOVEMENT
		
	MOVE_LEFT_PADDLE_DOWN:
		MOV AX,PADDLE_VELOCITY
		ADD PADDLE_LEFT_Y,AX
		MOV AX,WINDOW_HEIGHT
		SUB AX,WINDOW_BOUNDS
		SUB AX,PADDLE_HEIGHT
		CMP PADDLE_LEFT_Y,AX ;CHECK IF PADDLE_LEFT_Y < WINDOWS_HEIGHT (F: JUMP TO FIX_PADDLE_LEFT_BOTTOM_POSITION)
		JG  FIX_PADDLE_LEFT_BOTTOM_POSITION
		JMP CHECK_RIGHT_PADDLE_MOVEMENT
		
		FIX_PADDLE_LEFT_BOTTOM_POSITION:
			MOV PADDLE_LEFT_Y,AX
			JMP CHECK_RIGHT_PADDLE_MOVEMENT
	
	;FOR RIGHT PADDLE MOVEMENT
	CHECK_RIGHT_PADDLE_MOVEMENT:
	;WE DON'T NEED TO CHECK KEYPRESS AGAIN B/C THIS LABEL IS EXECUTED WHEN 'W' AND 'S' ARE NOT PRESSED 
	
	;IF IT IS 'o' OR 'O' MOVE UP
	CMP AL,6FH ;ASCII FOR 'o' IN HEX
	JE MOVE_RIGHT_PADDLE_UP
	
	CMP AL,4FH ;ASCII FOR 'W' IN HEX
	JE MOVE_RIGHT_PADDLE_UP
	
	;IF IT IS 'l' OR 'L' MOVE DOWN
	CMP AL,6CH ;ASCII FOR 'l' IN HEX
	JE MOVE_RIGHT_PADDLE_DOWN
	
	CMP AL,4CH ;ASCII FOR 'L' IN HEX
	JE MOVE_RIGHT_PADDLE_DOWN
	
	;IF EITHER IS NOT THE CASE,THEN THE KEY PRESS IS MAYBE FOR THE EXIT PROCEDURE
	JMP EXIT_PADDLE_MOVEMENT
	
	MOVE_RIGHT_PADDLE_UP:
		MOV AX,PADDLE_VELOCITY
		SUB PADDLE_RIGHT_Y,AX
		MOV AX,WINDOW_BOUNDS ;CHECK IF PADDLE_RIGHT_Y > WINDOWS_BOUNDS (F: JUMP TO FIX_PADDLE_RIGHT_TOP_POSITION)
		CMP PADDLE_RIGHT_Y,AX
		JL FIX_PADDLE_RIGHT_TOP_POSITION
		JMP EXIT_PADDLE_MOVEMENT
		
		FIX_PADDLE_RIGHT_TOP_POSITION:
			MOV AX,WINDOW_BOUNDS
			MOV PADDLE_RIGHT_Y,AX
			JMP EXIT_PADDLE_MOVEMENT
		
	MOVE_RIGHT_PADDLE_DOWN:
		MOV AX,PADDLE_VELOCITY
		ADD PADDLE_RIGHT_Y,AX
		MOV AX,WINDOW_HEIGHT
		SUB AX,WINDOW_BOUNDS
		SUB AX,PADDLE_HEIGHT
		CMP PADDLE_RIGHT_Y,AX ;CHECK IF PADDLE_RIGHT_Y < WINDOWS_HEIGHT (F: JUMP TO FIX_PADDLE_RIGHT_BOTTOM_POSITION)
		JG  FIX_PADDLE_RIGHT_BOTTOM_POSITION
		JMP EXIT_PADDLE_MOVEMENT
		
		FIX_PADDLE_RIGHT_BOTTOM_POSITION:
			MOV PADDLE_RIGHT_Y,AX
			JMP EXIT_PADDLE_MOVEMENT
			
	EXIT_PADDLE_MOVEMENT:
		RET
MOVE_PADDLES ENDP

DRAW_BALL PROC 				;PROCEDURE TO DRAW THE BALL
	
	MOV CX,BALL_X 			;SET THE INITIAL COLUMN OF THE PIXEL
	MOV DX,BALL_Y 			;SET THE INITIAL ROW OF THE PIXEL
	
	;DRAWING THE (4 x 4) BALL USING THIS PIXEL
	DRAW_BALL_HORIZONTAL:
		MOV AH,0CH 			;SET THE CONFIGURATION TO WRITING A PIXEL
		MOV AL,0FH 			;SET WHITE COLOR OF THE PIXEL
		MOV BH,00H 			;SET THE PAGE NUMBER 
		INT 10H
		
		INC CX 				; CX = CX + 1 incrementing column
		; CX - BALL_X > BALL_SIZE (T: MOVE TO THE NEXT ROW, F: INC COLUMN,CONTINUE TO NEXT COLUMN)
		MOV AX,CX 			;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,BALL_X
		CMP AX,BALL_SIZE
		JNG DRAW_BALL_HORIZONTAL 	;IF AX < BALL_SIZE, "JUMP NOT GREATER" LOOPING TO DRAW HORIZONTALLY UNTIL IT = BALL_SIZE
		
		MOV CX,BALL_X 		;IT GOES BACK TO INITIAL THE COL
		INC DX 				;incrementing THE ROW, ADVANCE TO NEW LINE
		; dX - BALL_Y > BALL_SIZE (T: EXIT THIS PROCEDURE, F: INC ROW,CONTINUE TO NEXT LINE)
		MOV AX,DX 			;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,BALL_Y 
		CMP AX,BALL_SIZE 	;CHECKING TO DRAW VERTICALLY UNTIL IT = BALL_SIZE
		JNG DRAW_BALL_HORIZONTAL
	RET
DRAW_BALL ENDP

RESET_BALL_POSITION PROC			;RESET THE BALL position TO THE ORIGINAL ONE, WE MADE BALL TO START FROM CENTER

	MOV AX,BALL_ORIGINAL_X
	MOV BALL_X,AX
	
	MOV AX,BALL_ORIGINAL_Y
	MOV BALL_Y,AX
	
	NEG BALL_VELOCITY_X
	NEG BALL_VELOCITY_Y
	
	RET
RESET_BALL_POSITION ENDP

DRAW_PADDLES PROC
	MOV CX,PADDLE_LEFT_X 			;SET THE INITIAL COLUMN OF THE PIXEL
	MOV DX,PADDLE_LEFT_Y 			;SET THE INITIAL ROW OF THE PIXEL
	
	DRAW_PADDLE_LEFT_HORIZONTAL:
		MOV AH,0CH 					;SET THE CONFIGURATION TO WRITING A PIXEL
		MOV AL,0FH 					;SET WHITE COLOR OF THE PIXEL
		MOV BH,00H 					;SET THE PAGE NUMBER 
		INT 10H
		
		INC CX 						;CX = CX + 1 incrementing column
		; CX - PADDLE_LEFT_X > PADDLE_WIDTH (T: MOVE TO THE NEXT ROW, F: INC COLUMN,CONTINUE TO NEXT COLUMN)
		MOV AX,CX 			;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,PADDLE_LEFT_X
		CMP AX,PADDLE_WIDTH
		JNG DRAW_PADDLE_LEFT_HORIZONTAL;IF AX < PADDLE_WIDTH, "JUMP NOT GREATER" LOOPING TO DRAW HORIZONTALLY UNTIL IT = PADDLE_WIDTH
		
		MOV CX,PADDLE_LEFT_X 		;IT GOES BACK TO INITIAL THE COL
		INC DX 						;incrementing THE ROW, ADVANCE TO NEW LINE
		; dX - PADDLE_LEFT_Y > PADDLE_HEIGHT (T: EXIT THIS PROCEDURE, F: INC ROW,CONTINUE TO NEXT LINE)
		MOV AX,DX 					;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,PADDLE_LEFT_Y 
		CMP AX,PADDLE_HEIGHT 		;CHECKING TO DRAW VERTICALLY UNTIL IT = PADDLE_HEIGHT
		JNG DRAW_PADDLE_LEFT_HORIZONTAL
		
	MOV CX,PADDLE_RIGHT_X			;SET THE INITIAL COLUMN OF THE PIXEL
	MOV DX,PADDLE_RIGHT_Y 			;SET THE INITIAL ROW OF THE PIXEL
	
	DRAW_PADDLE_RIGHT_HORIZONTAL:
		MOV AH,0CH 					;SET THE CONFIGURATION TO WRITING A PIXEL
		MOV AL,0FH 					;SET WHITE COLOR OF THE PIXEL
		MOV BH,00H 					;SET THE PAGE NUMBER 
		INT 10H
		
		INC CX 						; CX = CX + 1 incrementing column
		; CX - PADDLE_RIGHT_X > PADDLE_WIDTH (T: MOVE TO THE NEXT ROW, F: INC COLUMN,CONTINUE TO NEXT COLUMN)
		MOV AX,CX 					;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,PADDLE_RIGHT_X
		CMP AX,PADDLE_WIDTH
		JNG DRAW_PADDLE_RIGHT_HORIZONTAL ;IF AX < PADDLE_WIDTH, "JUMP NOT GREATER" LOOPING TO DRAW HORIZONTALLY UNTIL IT = PADDLE_WIDTH
		
		MOV CX,PADDLE_RIGHT_X 		;IT GOES BACK TO INITIAL THE COL
		INC DX 						;incrementing THE ROW, ADVANCE TO NEW LINE
		; dX - PADDLE_RIGHT_Y > PADDLE_HEIGHT (T: EXIT THIS PROCEDURE, F: INC ROW,CONTINUE TO NEXT LINE)
		MOV AX,DX 					;STORE THE VALUE SO THAT IT DOES NOT GETS LOST
		SUB AX,PADDLE_RIGHT_Y 
		CMP AX,PADDLE_HEIGHT 		;CHECKING TO DRAW VERTICALLY UNTIL IT = PADDLE_HEIGHT
		JNG DRAW_PADDLE_RIGHT_HORIZONTAL
		
	RET
DRAW_PADDLES ENDP

DRAW_UI PROC
	
	;DRAW THE POINTS OF THE LEFT PLAYER (PLAYER ONE)
	
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,04H 						;ROW POS OF CURSOR
	MOV DL,06H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_PLAYER_ONE_POINTS	;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H									;PRINT THE STRING
	
	;DRAW THE POINTS OF THE RIGHT PLAYER (PLAYER TWO)
	
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,04H 						;ROW POS OF CURSOR
	MOV DL,1FH 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_PLAYER_TWO_POINTS	;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H									;PRINT THE STRING
	
	RET
DRAW_UI ENDP

UPDATE_TEXT_PLAYER_ONE_POINTS PROC
	XOR AX,AX 					;CLEANING THE AX REGISTER
	MOV AL,PLAYER_ONE_POINTS	;given for e.g. p1 -> 2 points => AL,2
	
	;now before printing to the screen, we convert the decimal value to the ascii code CHARACTER
	;we can do this by adding 48 or 30H to AL (number to ascii)
	;subtacting 48 or 30H (ascii to number)
	ADD AL,30H
	MOV [TEXT_PLAYER_ONE_POINTS],AL		;move the value of AL to the address of the 1st index of this variable
	RET
UPDATE_TEXT_PLAYER_ONE_POINTS ENDP

UPDATE_TEXT_PLAYER_TWO_POINTS PROC
	XOR AX,AX 					;CLEANING THE AX REGISTER
	MOV AL,PLAYER_TWO_POINTS	;given for e.g. p1 -> 2 points => AL,2
	
	;now before printing to the screen, we convert the decimal value to the ascii code CHARACTER
	;we can do this by adding 48 or 30H to AL (number to ascii)
	;subtacting 48 or 30H (ascii to number)
	ADD AL,30H
	MOV [TEXT_PLAYER_TWO_POINTS],AL		;move the value of AL to the address of the 1st index of this variable
	RET
UPDATE_TEXT_PLAYER_TWO_POINTS ENDP

DRAW_GAME_OVER_MENU PROC	;DRAW THE GAME OVER MENU
	
	CALL CLEAR_SCREEN 		;CLEAR THE SCREEN BEFORE DISPLAYING THE MENU
	
	;SHOWS THE MENU TITLE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,04H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_GAME_OVER_TITLE		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H		

	;Shows the winner
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,06H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	CALL UPDATE_WINNER_TEXT
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_GAME_OVER_WINNER		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	
	
	;Shows the PLAY AGAIN MESSAGE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,08H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 									;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_GAME_OVER_PLAY_AGAIN		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	
	
	;Shows the MAIN MENU MESSAGE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,0AH 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 									;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_GAME_OVER_MAIN_MENU		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	
	
	;WAITS FOR KEY PRESS
	MOV AH,00H
	INT 16H
	
	;IF THE PRESSED KEY WAS 'R' OR 'r' ->RESTART game
	CMP AL,'R'
	JE RESTART_GAME
	CMP AL,'r'
	JE RESTART_GAME
	;IF THE PRESSED KEY WAS 'E' OR 'E' ->EXIT TO MAIN MENU
	CMP AL,'E'
	JE EXIT_TO_MAIN_MENU
	CMP AL,'e'
	JE EXIT_TO_MAIN_MENU
	RET
	
	RESTART_GAME:
		;RE-ACTIVE THE GAME AGAIN
		MOV GAME_ACTIVE,01H
		RET
	EXIT_TO_MAIN_MENU:
		MOV GAME_ACTIVE,00H
		MOV CURRENT_SCENE,00H	;KEEPS TRACK OF THE CURRENT MENU OR SCENE WE CURRENTLY AT
		RET
	
DRAW_GAME_OVER_MENU ENDP

DRAW_MAIN_MENU PROC
	CALL CLEAR_SCREEN
	
	;SHOWS THE MENU TITLE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,04H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_MAIN_MENU_TITLE		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	

	;SHOWS THE SINGLEPLAYER MESSAGE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,06H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 									;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_MAIN_MENU_SINGLEPLAYER	;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	
	
	;SHOWS THE MULTIPLAYER MESSAGE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,08H 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 									;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_MAIN_MENU_MULTIPLAYER	;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H	
	
	;SHOWS THE EXIT MESSAGE
	MOV AH,02H 						;SET CURSOR POSITION FUNCTION
	MOV BH,00H 						;SET PAGE NUMBER
	MOV DH,0AH 						;ROW POS OF CURSOR
	MOV DL,04H 						;COL POS OF CURSOR
	INT 10H
	
	MOV AH,09H 								;WRITE STRING TO STANDARD OUTPUT
	MOV DX,OFFSET TEXT_MAIN_MENU_EXIT		;GIVE THE ADDRESS OF THE 1ST POSITION OF STRING
	INT 21H

	MAIN_MENU_WAIT_FOR_KEY:
		;WAITS FOR KEY PRESS
		MOV AH,00H
		INT 16H	
		
		;CHECK WHICH KEY WAS PRESSED
		CMP AL,'S'
		JE START_SINGLEPLAYER
		CMP AL,'s'
		JE START_SINGLEPLAYER
		CMP AL,'M'
		JE START_MULTIPLAYER
		CMP AL,'m'
		JE START_MULTIPLAYER
		CMP AL,'E'
		JE EXIT_GAME
		CMP AL,'e'
		JE EXIT_GAME
		JMP MAIN_MENU_WAIT_FOR_KEY
		
		START_SINGLEPLAYER:
			MOV CURRENT_SCENE,01H
			MOV GAME_ACTIVE,01H
			RET
		START_MULTIPLAYER:
			JMP MAIN_MENU_WAIT_FOR_KEY
		EXIT_GAME:
			MOV EXITING_GAME,01H
			RET
		
DRAW_MAIN_MENU ENDP

UPDATE_WINNER_TEXT PROC 			;UPDATES WINNER TEXT WITH WINNER_INDEX BEFORE DRAWING IT (PLAYER 0 WON) WE WANT TO UPDATE '0'
	MOV AL,WINNER_INDEX
	ADD AL,30H						;FIX THE ASCII
	MOV [TEXT_GAME_OVER_WINNER+7],AL	;REACH THE DESIRED CHARACTER'S INDEX AND UPDATE THE VALUE ON IT
	
	RET
UPDATE_WINNER_TEXT ENDP

CLEAR_SCREEN PROC 		;CLEAR THE SCREEN by restarting the video mode 

	MOV AH,00H 			;SET THE CONFIGURATION TO VIDEO MODE
	MOV AL,0DH 			;resolution 320 x 200 graphics
	INT 10H 			;SETTING INTERRUPT FOR GRAPHICS VIDEO MODE
		
	MOV AH,0BH 			;Set THE FUNCTION
	MOV BH,00H 			;TO background/border color
	MOV BL,00H 			;SET Background/Border color TO BLACK
	INT 10H
	
	RET
CLEAR_SCREEN ENDP

CONCLUDE_EXIT_GAME PROC	;GOES BACK TO THE TEXT MODE
	
	MOV AH,00H 			;SET THE CONFIGURATION TO VIDEO MODE
	MOV AL,02H 			;resolution 320 x 200 graphics
	INT 10H 			;SETTING INTERRUPT FOR GRAPHICS VIDEO MODE
	
	MOV AH,4CH
	INT 21H
	
	RET
CONCLUDE_EXIT_GAME ENDP
END MAIN